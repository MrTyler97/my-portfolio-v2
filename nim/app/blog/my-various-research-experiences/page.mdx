export const metadata = {
  title: 'Autophagy, 3D Models, and ...Drone Maze Navigation?',
  description:
    'Autophagy, 3D Models, and ...Drone Maze Navigation? Explaining all of my various research',
  alternates: {
    canonical: '/blog/my-various-research-experiences',
  },
};

<Cover
  src="/ResearchPic1.jpeg"
  alt="Me presenting at the Undegraduate Symposium"
  caption="Undegraduate Symposium 45"
/>

# Autophagy, 3D Models, and Autonomus Drone Navigation?

During my time at Eastern Michigan, I participated in several meaningful projects outside the classroom. I collaborated with the Chemistry Department to enhance their 3D modeling pipeline and worked with the Computer Science Department to program autonomous drones capable of navigating through mazes autonomously.

---

## Autophagic Pipeline Automation

Cells get broken down and recycled for energy through a process called autophagy. How can we study this phenomena and understand it at deeper level? The answer is simulating the process.

- **Refactoring**: I improved the pipeline's architecture by condensing functionality from three separate scripts into a single script.
- **Automation**: I revamped the pipeline interface to allow for automated, continuous operation with adjustable cell variability parameters. 
- **Modeling**: I optimized key function parameters to improve CompuCell3D modeling and integrated Matplotlib to provide additional 3D visualization capabilities.

<Cover
  src="/ResearchPic3.png"
  alt="3D Model slide"
  caption="Autophagic Body"
/>


## Autonomus Drone

I was responsible for developing a navigation solution that enabled an autonomous drone to successfully traverse any maze. This challenge required critical thinking and the design of a scalable algorithm capable of solving a universal pathfinding problem across multiple test cases.

### Challenges

- **Logic**: The solution was reduced to three directional turns: a 90-degree left turn, a 180-degree right turn, and a final 90-degree right turn after wall detection. This sequence enabled the drone to navigate out of any maze configuration, including dead ends. This solution may sound rudimentary now but the process of creating this logic took me days. 
- **Sensors**: The CoDrone’s sensors lacked precision, and I was unable to adjust their accuracy through code. This occasionally caused unstable wall detection and unreliable landings.

<Cover
  src="/drone.jpg"
  alt="Drone workstation"
  caption="Drone Workstation"
/>

### Algorithm Design 
The algorithm employs a triple nested loop to evaluate multiple conditions that determine the drone’s direction and movement. Timers within the loops track movement duration, enabling the drone to assess its progress through the maze. This step is crucial in preventing the drone from turning back toward previously traversed paths.

In hindsight, the solution could certainly be improved. The use of a triple nested loop results in a time complexity of O(n³), making it a relatively inefficient, greedy approach. However, at the time, I had only completed one programming course.
```
while start_time < end_time:
    # wall1 check
    while(True):
        count += count + 1
        start_time = time.time()  # update the time once the sequence is done
        move_time = time.time() #stores time when we start moving Constant (only updated once)
        while wall1 == False:
            if drone.detect_wall(60):
                wall_time = time.time()
                wall1 = True
            else:
                drone.move(.3)
                start_time = time.time()
        if count != 1:
            drone.set_pitch(-25)
            drone.move(1)
            drone.set_pitch(0)
            drone.set_yaw(-100)  # turn wheel right
            drone.move(.75)  # move .75 sec
            drone.set_yaw(0)  # reset wheel
            drone.set_pitch(25)
        if(wall_time > move_time + 2): #180 turn condition 
            wall1 = False
            break
        drone.set_pitch(25)
        drone.move(1)
        drone.set_pitch(0)
        drone.set_yaw(100)
        drone.move(1.5)
        drone.set_yaw(0)
        drone.set_pitch(25)
        move_time = time.time()
        while wall2 == False:
            if drone.detect_wall(60):
                wall_time = time.time()
                wall2 = True
            else:
                drone.move(.3)
                start_time = time.time()



drone.land()
drone.close()
```

---

## Conclusion

These opportunities allowed me to hone my skills in system design, algorithm creation, and problem solving. More importantly, it strengthened my technical communication, teamwork, and ability to interpret client requirements.

---
